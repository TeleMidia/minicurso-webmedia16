\section{Plugins}
\label{sec:plugins}
Até agora só vimos como usar elementos já definidos pelo Gstreamer (e.g.
``filesrc'', ``alsasink'').  Nesta seção iremos discutir como é possível criar
novos tipos de elementos.  No Gstreamer, novos tipos de elementos podem ser
criados estendendo a classe base \emph{GstElement}.  Também é possível encapsular
esses novos elementos em plugins que podem ser distribuidos separadamente,
instalados e carregados dinamicamente. 

%Esta seção apresenta um exemplo e discute a API de plugins do Gstreamer.
%Espera-se que ao final dela, o leitor tenha uma visão geral de como criar novos
%tipos de elementos que podem ser usados em um \emph{pipeline}.

%Os plugins do Gstreamer podem ser divididos em quatro categorias principais:
%\emph{source}, \emph{sink}, \emph{transform}, and \emph{processing} plugin.

\subsection*{Elemento ``Dummy''}
Para entendermos como desenvolver um novo elemento para  o GStreamer, iremos
começar com um exemplo simples, que ao receber algum dado no seu \emph{sink
pad} irá apenas imprimir o tamanho do buffer recebido e retransmitir esses
dados em seu \emph{source pad}.  Iremos chamar esse novo elemento de
``myfilter''.  A prática de desenvolvê-lo irá nos permitir identificar as
principais funções que devem ser implementadas por um novo elemento do
Gstreamer e como encapsulá-lo em um plugin.  O código fonte desse exemplo está
divido em dois arquivo (\C{myfilter.h} e \C{myfilter.c}) e será detalhado a
seguir.

O arquivo \C{myfilter.h} (Listagem~\ref{lst:myfilter_h}) define o novo tipo de
elemento que queremos criar (\C{GstMyFilter}).  A definição desse novo tipo de
elemento segue o padrão do \emph{framework} GObject, e deve estender a classe
\C{GStElement} (definida no arquivo \C{gst/gst.h}).  Por isso, é necessário
criar as classes \C{GstMyFilter}~(linhas 6--9) e \C{GstMyFilterClass}~(linhas
11--13).  A classe \C{GstMyFilter} deve estender a classe \C{GstElement}, por
isso ela define o campo \C{element} do tipo \C{GstElement}, linha 7, e a classe
\C{GstMyFilterClass} define o campo \C{parent_class} do tipo
\C{GstElementClass}, linha 12.  As linhas 15--24 definem macros padrões que
usam o \emph{framework} GObject para checagem e \C{casting} do novo tipo
definido.

\lstinputlisting[
style=display,
caption={Arquivo myfilter.h},
label={lst:myfilter_h},
]{src/myfilter.h}

O arquivo \C{myfilter.c} implementa as principais funções que permitem ao
Gstreamer carregar instâncias deste novo elemento e utilizá-las em
\emph{pipeline}s, bem como a lógica do processamento realizado por esse
elemento.  Entre essas, as principais são as funções de inicialização
(\C{*_init}) e a função de processamento (\C{*_chain}).

A função \C{gst_my_filter_class_init}~(linhas 30--48) é chamada na primeira vez
que um objeto do tipo \C{GstMyFilter} for definido.  Essa função define
metadados para a classe, por meio do método \C{gst_class_set_static_metadata},
e define os tipos de \emph{pads} do novo elemento que estamos criando, através
das chamadas \C{gst_element_class_add_pad_template}.  As chamadas dessa função
utilizam os dados de duas estruturas do tipo \C{GstStaticPadTemplate}
(respectivamente, \C{sink_factory} e \C{src_factory}, linhas 6--16).  A macro
\C{GST_STATIC_PAD_TEMPLATE} ajuda a preencher os valores dos campos de
estruturas \C{GstStaticPadTemplate}.
Como mencionado anteriormente, cada elemento do pipeline pode ter zero ou mais
\emph{source pads} e zero ou mais \emph{sink pads}.  O número de \emph{pads} e
quais são esses \emph{pads} podem ser definidos estaticamente ou dinamicamente.
No nosso exemplo, queremos um elemento que tenha apenas um \emph{source} e um
\emph{sink pad}.  Por isso, a definição dos \emph{pads} desse elemento é feita
de forma estática.

A função \C{gst_my_filter_init}~(linhas 50--61) é chamada quando uma nova
instância da classe \C{GstMyFilter} é criada.  Ela basicamente cria as
instâncias da classe \C{GstPad} relacionadas a cada um dos \emph{pads} do
elemento \emph{GstMyFilter}, chamadas \C{gst_pad_new_from_static_template}
(linhas 53 e 58).  Além disso, é também nessa função que é definido que  função
\C{gst_pad_set_chain_function} será chamada para processar novos dados que
cheguem para esse elemento.

A função \C{gst_my_filter_chain} ...

A macro \C{G_DEFINE_TYPE}, linha 4, também faz parte do
\emph{framework} GObject e expande para a declaração das funções de
inicialização de classe (neste caso as funções \C{gst_my_filter_init} e
\C{gst_my_filter_class_init}).  Além disso, esta macro também expande para 
outras funções e variáveis úteis para o \emph{framework}, tais como
\C{*_get_type()} e \C{*_parent_class}.

Entre as linhas 70 e 78 temos as definições relacionadas ao encapsulamento do
novo elemento como um plugin do GStreamer.  TODO.

\lstinputlisting[
style=display,
caption={Arquivo myfilter.c.},
label={lst:myfilter_c},
]{src/myfilter.c}

Coisas importantes para discutirmos:
\begin{itemize}
  \item \C{GST_STATIC_PAD_TEMPLATE}
  \item \C{gst_my_filter_class_init} 
  \item \C{gst_myfilter_init} 
  \item \C{myfilter_plugin_init}
  \item \C{myfilter_chain}
  \item \C{GST_PLUGIN_DEFINE}
  \item Definição de propriedades?
  \item Eventos?
\end{itemize}

%\subsection*{Especificando os pads}
%Como mencionado anteriormente, a comunicação entre os elementos é gerenciada
%usando \emph{pads}.  Sendo assim, ao criar um plugin também devemos especificar
%quantos e quais tipos de \emph{pad} esse plugin aceita como entrada e saída.

%A comunicação entre os plugins pode ser classificada em duas subcategorias:
%\emph{mensagens de controle} (ou eventos) e \emph{mensagens de conteúdo de
%mídia} (ou buffers).  As mensagens de controle são cruciais para controlar o
%processamento das mídias.  As mensagens de conteúdo de mídia são responsáveis
%por transferir o conteúdo que precisa ser processado.

%\subsection*{A função plugin\_init}
%\begin{itemize}
%  \item plugin\_init
%  \item chain: Essa função é onde todo o processamento dos dados é realizado.
%        No caso de plugins simples as funções \_chain () são geralmente lineares,
%        para cada buffer na enntrada um buffer será gerado na saída também.
%        Below is a very simple implementation of a chain function: 
%  \item event
%\end{itemize}

\subsection*{Testando o seu plugin}
Para compilar o nosso plugin devemos gerar uma biblioteca dinâmica (.dll no
Windows ou .so no Linux).  O comando a seguir compila o exemplo desenvolvido
acima:

\begin{lstlisting}[style=command]
@\$@ cc -share -fPIC \
  `pkg-config --cflags --libs gstreamer-1.0 gstreamer-base-1.0`\
  myfilter.c -o myfilter.so
\end{lstlisting}

O comando a seguir carrega o plugin myfilter que desenvolvemos em um pipeline
simples:

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     audiotestsrc !  myfilter ! alsasink
\end{lstlisting}

Como o plugin que desenvolvemos recebe qualquer tipo de dado (tipo de \emph{pad
sink} \C{ANY}, é possível utilizá-lo usá-lo em qualquer pipeline.  Por exemplo,
compare a execução do \emph{pipeline} anterior com a execução seguinte
pipeline:

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     videotestsrc ! myfilter ! ximagesink
\end{lstlisting}

\subsection*{Um plugin para filtro de vídeo}
Os elementos do Gstreamer são derivados da classe base \emph{GstElement}.  Além
disso, outras classes distribuídas nos pacotes \C{gst-plugin-base} também podem
ser usadas para criar novos plugins.  As principais são: \C{GstBaseSrc}, classe
base para plugins tipo \emph{source} (ou produtores); \C{GstBaseSink}, classe
base para plugins do tipo \emph{sink} (ou consumidores); \C{GstBaseTransform},
classe base para plugins do tipo \emph{tranform} (ou filtros); e \C{GstBin},
cria um manipulador de elementos customizáveis similar ao GstPipeline.  A
Figura~\ref{fig:plugins_class_hierachy} evidencia como essas classes estão
relacionadas.
%  \item{GstElement}--a classe base mais genérica, das quais as outras classes
%                     bases derivam;

\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {GObject}
    child {
%      node {GInitiallyUnknown}
%      child {
        node {GstElement}
        child {node{GstBaseSrc}}
        child {node{GstBaseSink}}
        child {node{GstBin}}
        child {
          node {GstBaseTransform}
          child {node {GstAudioFilter}}
          child {node {GstVideoFitter}}
        }
%      }
    };
  \end{tikzpicture}
  \label{fig:plugins_class_hierarch}
  \caption{Hierarquia de classes evidenciando algumas classes importantes no
           desenvolvimento de plugins.}
\end{figure}

\lstinputlisting[
style=display,
caption={myvideofilter.h},
label={lst:myvideofilter_h},
]{src/myvideofilter.h}

\lstinputlisting[
style=display,
caption={myvideofilter.c},
label={lst:myvideofilter_c},
]{src/myvideofilter.c}

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. filesrc location=bunny.ogg ! 
     oggdemux ! theoradec ! videoconvert ! videoscale ! \
     video/x-raw,width=720 ! myvideofilter ! ximagesink
\end{lstlisting}

\noindent compare com o resultado sem o nosso filtro:
\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     audiotestsrc ! audioconvert ! alsasink
\end{lstlisting}

