\section{Plugins}
\label{sec:plugins}
Até agora só vimos como usar elementos já definidos pelo Gstreamer (e.g.
``filesrc'', ``alsasink'').  Nesta seção iremos discutir como é possível criar
novos tipos de elementos.  No Gstreamer, novos tipos de elementos podem ser
criados por meio de plugins, os quais podem ser distribuidos separadamente,
instalados e usados em um \emph{pipeline}. 

%Esta seção apresenta um exemplo e discute a API de plugins do Gstreamer.
%Espera-se que ao final dela, o leitor tenha uma visão geral de como criar novos
%tipos de elementos que podem ser usados em um \emph{pipeline}.

%Os plugins do Gstreamer podem ser divididos em quatro categorias principais:
%\emph{source}, \emph{sink}, \emph{transform}, and \emph{processing} plugin.

Os plugins do Gstreamer são derivados da classe base \emph{GstElement}.  Além
disso, outras classes distribuídas nos pacotes \C{gst-plugin-base} também podem
ser usadas para criar novos plugins.  As principais são: \C{GstBaseSrc}, classe
base para plugins tipo \emph{source} (ou produtores); \C{GstBaseSink}, classe
base para plugins do tipo \emph{sink} (ou consumidores); \C{GstBaseTransform},
classe base para plugins do tipo \emph{tranform} (ou filtros); e \C{GstBin},
cria um manipuladores de plugins customizáveis similar ao GstPipeline.  A
Figura~\ref{fig:plugins_class_hierachy} evidencia como essas classes estão
relacionadas.
%  \item{GstElement}--a classe base mais genérica, das quais as outras classes
%                     bases derivam;

\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {GObject}
    child {
%      node {GInitiallyUnknown}
%      child {
        node {GstElement}
        child {node{GstBaseSrc}}
        child {node{GstBaseSink}}
        child {node{GstBin}}
        child {
          node {GstBaseTransform}
          child {node {GstAudioFilter}}
          child {node {GstVideoFitter}}
        }
%      }
    };
  \end{tikzpicture}
  \label{fig:plugins_class_hierarch}
  \caption{Hierarquia de classes evidenciando algumas classes importantes no
           desenvolvimento de plugins.}
\end{figure}

\subsection*{Plugin ``Dummy''}
Para melhor entendermos como desenvolver um plugin para o GStreamer, iremos
começar com um exemplo simples, que ao receber algum dado no seu \emph{sink
pad} irá apenas imprimir o tamanho do buffer recebido e retransmitir esses
dados em seu \emph{source pad}.  O principal objetivo deste plugin, que
obviamente não é muito útil na prática, é identificar as principais funções que
devem ser implementadas por um novo plugin do Gstreamer.  O código fonte desse
exemplo está divido em dois arquivo (\C{myfilter.h} e \C{myfilter.c}) os quais
são detalhados a seguir.

O arquivo \C{myfilter.h} (Listagem~\ref{lst:myfilter_h}) define o novo elemento
que queremos criar (\C{GstMyFilter}) o qual deve ser uma subclasse de
\C{GstElement}.  A definição desse novo tipo segue o padrão do \emph{framework}
GObject.  Por isso, é necessário criar as estruturas \C{_GstMyFilter} e
\C{_GstMyFilterClass}.  A classe \C{GstMyFilter} deve estender a classe
\C{GstElement}, por isso ela define o campo \C{element} do tipo \C{GstElement},
linha 7, e a classe \C{GstMyFilterClass} define o campo \C{parent_class} do
tipo \C{GstElementClass}, linha 12.  As linhas 15--24 definem macros padrões
que usam o \emph{framework} GObject para checagem e \C{casting} do novo tipo
definido.

\lstinputlisting[
style=display,
caption={Arquivo myfilter.h},
label={lst:myfilter_h},
]{src/myfilter.h}

O arquivo \C{myfilter.c} implementa as principais funções

\lstinputlisting[
style=display,
caption={.c},
label={lst:myfilter_c},
]{src/myfilter.c}

Coisas importantes para discutirmos:
\begin{itemize}
  \item \C{GST_STATIC_PAD_TEMPLATE}
  \item \C{gst_my_filter_class_init} 
  \item \C{gst_myfilter_init} 
  \item \C{myfilter_plugin_init}
  \item \C{myfilter_chain}
  \item \C{GST_PLUGIN_DEFINE}
\end{itemize}

\subsection*{Especificando os pads}
Como mencionado anteriormente, a comunicação entre os elementos é gerenciada
usando \emph{pads}.  Sendo assim, ao criar um plugin também devemos especificar
quantos e quais tipos de \emph{pad} esse plugin aceita como entrada e saída.

A comunicação entre os plugins pode ser classificada em duas subcategorias:
\emph{mensagens de controle} (ou eventos) e \emph{mensagens de conteúdo de
mídia} (ou buffers).  As mensagens de controle são cruciais para controlar o
processamento das mídias.  As mensagens de conteúdo de mídia são responsáveis
por transferir o conteúdo que precisa ser processado.

\subsection*{A função plugin\_init}
\begin{itemize}
  \item plugin\_init
  \item chain: Essa função é onde todo o processamento dos dados é realizado.
        No caso de plugins simples as funções \_chain () são geralmente lineares,
        para cada buffer na enntrada um buffer será gerado na saída também.
        Below is a very simple implementation of a chain function: 
  \item event
\end{itemize}

\subsection*{Testando o seu plugin}
Para compilar o nosso plugin devemos gerar uma biblioteca dinâmica (.dll no
Windows ou .so no Linux).  O comando a seguir compila o exemplo desenvolvido
acima:

\begin{lstlisting}[style=command]
@\$@ cc -share -fPIC \
  `pkg-config --cflags --libs gstreamer-1.0 gstreamer-base-1.0`\
  myfilter.c -o myfilter.so
\end{lstlisting}

O comando a seguir carrega o plugin myfilter que desenvolvemos em um pipeline
simples:

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     audiotestsrc !  myfilter ! alsasink
\end{lstlisting}

Como o plugin que desenvolvemos recebe qualquer tipo de dado (tipo de \emph{pad
sink} \C{ANY}, é possível utilizá-lo usá-lo em qualquer pipeline.  Por exemplo,
compare a execução do pipeline anterior com a execução seguinte pipeline:

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     videotestsrc ! myfilter ! alsasink
\end{lstlisting}

\subsection*{Um plugin para filtro de vídeo}

\lstinputlisting[
style=display,
caption={myvideofilter.h},
label={lst:myvideofilter_h},
]{src/myvideofilter.h}

\lstinputlisting[
style=display,
caption={myvideofilter.c},
label={lst:myvideofilter_c},
]{src/myvideofilter.c}

\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. filesrc location=bunny.ogg ! 
     oggdemux ! theoradec ! videoconvert ! videoscale ! \
     video/x-raw,width=720 ! myvideofilter ! ximagesink
\end{lstlisting}

\noindent compare com o resultado sem o nosso filtro:
\begin{lstlisting}[style=command]
@\$@ gst-launch-1.0 --gst-plugin-path=. \
     audiotestsrc ! audioconvert ! alsasink
\end{lstlisting}

